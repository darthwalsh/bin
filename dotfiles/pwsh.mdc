---
name: pwsh
description: PowerShell Guidelines applies to all powershell files
globs: ["**/*.ps1", "**/*.psm1"]
---

When creating a new script, see newps1.ps1 `Set-Content` content for the template.

Scripts start with:
```powershell
$script:ErrorActionPreference = "Stop"
Set-StrictMode -Version Latest
```

If I have `[CmdletBinding(SupportsShouldProcess)]`, nested cmdlets that support `ShouldProcess` will inherit the `-WhatIf`; so don't need `if ($PSCmdlet.ShouldProcess(...))` block.

Assume that bin/ is on the $PATH. Instead of `& "$PSScriptRoot/the-script.ps1" arg1` just use `the-script arg1`
Don't hardcode `~/code/bin` to find relative paths, use `Get-Bin` which returns the bin repo root.
To find an unknown command `foo`, run `pwsh -c 'wh foo'`. Look for the first non-alias CommandType, and then look at Source.

When running native commands, need to try-catch if the exit code is expected to be non-zero.
When passing flags to commands, use the long flag names.

Don't need `if ($LASTEXITCODE -ne 0)`: `PSNativeCommandErrorActionPreference` is Enabled by default, so `$ErrorActionPreference = "Stop"` will stop execution even for native programs. If a command exits with another exit code, it will throw.

When making a semantic wrapper around other CLIs, prefer splatting them: `tool $someParam @args`

Use `Temp:\` as a scratch place, with `bak` to backup files. When passing temp paths to other tools, use `Convert-Path` to get a real filesystem path.

Rely on bash-like polyfill `export KEY=VALUE` (sets both `env:` and `$KEY` variable) and `unset KEY` to remove them

Prefer string interpolation over -f operator.
When writing string to stdout, just put the string on its own line, no Write-Output.

When creating complicated functionality, create tests/the-cmd.Tests.ps1 and implement Pester tests.
